from typing import List, Dict
from datetime import datetime, timedelta

class Order:
    def __init__(self, order_id, order_type, features, quantity, priority, deadline):
        self.order_id = order_id
        self.order_type = order_type  # e.g., P1, PO, regular
        self.features = features
        self.quantity = quantity
        self.priority = priority
        self.deadline = deadline

class Mold:
    def __init__(self, mold_id, capacity, compatible_types):
        self.mold_id = mold_id
        self.capacity = capacity
        self.compatible_types = compatible_types  # List of order types

class Employee:
    def __init__(self, employee_id, skills, prod_rate):
        self.employee_id = employee_id
        self.skills = skills  # List of order types
        self.prod_rate = prod_rate  # units per hour

class ScheduleSlot:
    def __init__(self, order_id, mold_id, employee_id, start_time, end_time):
        self.order_id = order_id
        self.mold_id = mold_id
        self.employee_id = employee_id
        self.start_time = start_time
        self.end_time = end_time

    def as_dict(self):
        return {
            "order_id": self.order_id,
            "mold_id": self.mold_id,
            "employee_id": self.employee_id,
            "start_time": self.start_time.strftime("%Y-%m-%d %H:%M"),
            "end_time": self.end_time.strftime("%Y-%m-%d %H:%M")
        }

def schedule_orders(orders: List[Order], molds: List[Mold], employees: List[Employee]) -> List[ScheduleSlot]:
    # Sort orders by priority (lower is higher priority) and deadline
    orders = sorted(orders, key=lambda o: (o.priority, o.deadline))
    schedule = []
    current_time = datetime.now()

    for order in orders:
        # Find compatible mold and employee
        compatible_molds = [m for m in molds if order.order_type in m.compatible_types]
        available_employees = [e for e in employees if order.order_type in e.skills]
        if not compatible_molds or not available_employees:
            continue

        # Pick the first available for simplicity (can optimize later)
        mold = compatible_molds[0]
        employee = available_employees[0]

        # Calculate production time
        prod_units_per_hour = min(mold.capacity, employee.prod_rate)
        hours_needed = order.quantity / prod_units_per_hour
        end_time = current_time + timedelta(hours=hours_needed)

        slot = ScheduleSlot(order.order_id, mold.mold_id, employee.employee_id, current_time, end_time)
        schedule.append(slot)

        # Advance time for next order (or keep track of resource usage for better optimization)
        current_time = end_time

    return schedule

# Example usage:
if __name__ == "__main__":
    # Demo data
    orders = [
        Order("ORD001", "P1", {"color": "red"}, 10, 1, datetime(2025, 8, 5)),
        Order("ORD002", "PO", {"color": "blue"}, 5, 2, datetime(2025, 8, 6)),
        Order("ORD003", "regular", {"color": "green"}, 12, 3, datetime(2025, 8, 10)),
    ]
    molds = [
        Mold("MOLD-A", 5, ["P1", "PO"]),
        Mold("MOLD-B", 10, ["regular", "P1"]),
    ]
    employees = [
        Employee("EMP-1", ["P1", "PO"], 6),
        Employee("EMP-2", ["regular"], 8),
    ]

    schedule = schedule_orders(orders, molds, employees)
    for slot in schedule:
        print(slot.as_dict())